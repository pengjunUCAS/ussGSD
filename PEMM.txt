  
  ###
  ###**************************************************************************************************************************
  ### R functions PEMM() and PEMMp().
  ###**************************************************************************************************************************
  ### Parametric end-member modelling using transformed probability density functions.
  ### Author: Jun Peng, Hunan University of Science and Technology, China. 
  ### Last updated, 2022.10.18.
  ### 
  ### Note that the current version of the program is developed for parametric end-member modelling 
  ### of single-sample grain-size distributions measured using the Malvern Mastersizer-2000/3000
  ### laser particle-size analyzer. So it can not ensure that the program will work equally 
  ### well for datasets measured from other types of particle-size analyzers.
  ### 
  ### Please contact Jun Peng (pengjun10@mails.ucas.ac.cn, or 656971673@qq.com) 
  ### if you have any problem during the application of the program or 
  ### if you want to report any bug encountered during the use of the program.
  ###**************************************************************************************************************************

  
  
  ###
  ###*******************************************************
  ### Load the required external R packages.
  ### Please make sure that the following packages have  
  ### been installed in your R calculation environment.
  ###=======================================================
  library(pracma)
  library(tgcd)
  
  
  
  ###
  ###**************************************************************************************************************************
  ### Function PEMM() is used for parametric end-member modelling of 
  ### grain-size distributions using transformed probability density functions. 
  ###==========================================================================================================================
  ### The function contains the following arguments.
  ###
  ###    GSDmat: A matrix storing the grain-size data used for analysis. The first row is 
  ###            the grain-size levels, and the remaining rows are the volume percentages 
  ###            of individual samples to be modelled. 
  ###
  ###     ncomp: An integer (from 1 to 13) indicating the number of endmembers to be modelled. 
  ###
  ###     model: A character indicating the model to be fitted,
  ###            "weibull0", "lognormal0", "skewnormal0", or "skewgnormal0".
  ###
  ###       mpd: An integer indicating the minimum distance (in indices) of peaks to be identified.
  ###
  ###       ctf: A numeric value (between -1 and 1) representing a critical threshold   
  ###            that controls the identification of peaks from the grain-size distribution.  
  ###            This argument can be used to prevent identifying a false peak characterised  
  ###            by a large positive second-order derivative. Specially, ctf=0 indicates 
  ###            peaks with second-order derivatives above zero will be precluded.  
  ###            The degree of precluding will be increasingly suppressed as ctf 
  ###            increases from -1 to 1.           
  ###
  ###      ntry: An integer indicating the number of trials in a trial-and-error protocol. 
  ###
  ###       kkf: A numeric value controlling the range of values from which random starting   
  ###            parameters will be generated during the "trial-and-error" protocol.
  ###
  ###  useIndex: A logical value indicating whether the index of a grain-size level will be  
  ###            used as the independent variable during the modelling process.
  ###
  ###       csv: A logical value indicating if the output results will be saved in CSV files. 
  ###
  ###   pdfname: A character indicating the name of the PDF file the modelling results will  
  ###            be written to. The results will not be returned to a PDF file if pdfname=NULL.
  ###
  ###        nr: An integer indicating the number of rows generated in the PDF file.
  ###
  ###        nc: An integer indicating the number of columns generated in the PDF file.
  ###==========================================================================================================================
  ### The function returns an invisible list containing the following elements.
  ###
  ###      fitGSD: A matrix containing the fitted/predicted grain-size distributions.
  ###
  ###   abundance: A matrix containing the abundances of grain-size distributions.
  ###
  ###   endmember: A matrix containing the optimized parametric endmembers.
  ###
  ###       Angle: A vector containing the minimized angles between measured and predicted 
  ###              grain-size distributions.
  ###
  ###   meanAngle: A numerical value indicating the mean of the minimized angles.
  ###         
  ### sdmeanAngle: A numerical value indicating the standard deviation of the mean of the 
  ###              minimized angles.
  ###
  ###          R2: A vector containing the squared correlation coefficients bettwen measured 
  ###              and predicted grain-size distributions.
  ###
  ###      meanR2: A numerical value indicating the mean of the squared correlation coefficients.
  ###
  ###    sdmeanR2: A numerical value indicating the standard deviation of the mean of the squared 
  ###              correlation coefficients.
  ###
  ###        pars: A matrix containing the optimized parameters describing parametric endmembers.
  ###
  ###          xm: A vector containg the optimized modes of endmembers.
  ###========================================================================================================================== 
  ### In addition, the function automatically writes the results to CSV files (i.e., "abundance.csv",
  ### "endmember.csv") if csv=TRUE and generates a plot sumamrying the results if pdfname!=NULL.
  ###==========================================================================================================================
  PEMM <- function(GSDmat, ncomp, model="weibull0", mpd=3, ctf=-0.1, 
                   ntry=50, kkf=0.2, useIndex=TRUE, csv=TRUE, pdfname=NULL, 
                   nr=10, nc=9) {

      GSDmat <- as.matrix(GSDmat)

      ###
      if(nrow(GSDmat)<2) 
      stop("Error: [GSDmat] should contain at least two rows!")

      ###
      stopifnot(length(ncomp)==1, is.numeric(ncomp), ncomp %in% 1:13,
                is.character(model), length(model)==1, 
                model %in% c("weibull0","lognormal0","skewnormal0","skewgnormal0"),
                is.numeric(mpd), length(mpd)==1, mpd>0,
                is.numeric(ctf), length(ctf)==1, ctf>=-1, ctf<=1,
                is.numeric(ntry), length(ntry)==1, ntry>=2, 
                is.numeric(kkf), length(kkf)==1, kkf>0, kkf<1,
                is.logical(useIndex), length(useIndex)==1,
                is.logical(csv), length(csv)==1,
                is.null(pdfname) || (is.character(pdfname) && length(pdfname)==1),
                is.numeric(nr), length(nr)==1, nr>0, 
                is.numeric(nc), length(nc)==1, nc>0)
        
      ###
      X <- GSDmat[-1,,drop=FALSE]

      ###
      m <- nrow(X)
      n <- ncol(X)

      ###
      xd <- as.numeric(GSDmat[1,])
      
      ### Check if the grain size levels are of log-scale.
      xd0xd0 <- round(diff(log(as.numeric(xd))),2)
      YESORNO <- all(xd0xd0==min(xd0xd0)) || all(xd0xd0 %% min(xd0xd0)==0)
      expGSlev <- ifelse(YESORNO, TRUE, FALSE)

      ###
      if (useIndex==TRUE) {

          xd1 <- seq(n)

          ###
          pab <- as.numeric(lm(xd1~log(xd))$coefficients)

      } else {

          xd1 <- xd

      } # end if.

      ### 
      ### The error function.
      ###---------------------
      erf <- function(x) { 2 * pnorm(x * sqrt(2)) - 1 }

      ###
      ### The function to be minimized.
      ###-------------------------------------
      minfunc <- function(p,xd,X,model) {

          X <- as.matrix(X)

          ###
          m <- nrow(X)
          n <- ncol(X)

          ###
          ###
          if (model %in% c("weibull0","lognormal0")) {

              ncomp <- length(p)/2

          } else if (model %in% c("skewnormal0","skewgnormal0")) {

              ncomp <- length(p)/3

          } # end if.

          ###
          B <- matrix(nrow=ncomp, ncol=n)

          ###
          if (model=="lognormal0") {

              for (i in 1:ncomp) {

                  xm <- abs(p[i])

                  ###
                  sigma <- abs(p[i+ncomp])+0.001
                   
                  ###
                  B[i,] <- 1/sqrt(2*pi)/sigma/xd*
                  exp(-0.5*((log(xd/xm)-sigma^2)/sigma)^2)
                  B[i,] <- B[i,]/sum(B[i,])

              } # end for.

          } else if (model=="weibull0") {

              for (i in 1:ncomp) {

                  xm <- abs(p[i])

                  ###
                  alpha <- abs(p[i+ncomp])+1

                  ###
                  B[i,] <- 1/xm*(alpha-1)*(xd/xm)^(alpha-1)*
                  exp(-(alpha-1)/alpha*(xd/xm)^alpha)
                  B[i,] <- B[i,]/sum(B[i,])

              } # end for.

          } else if (model=="skewnormal0") {

              for (i in 1:ncomp) {

                  xm <- abs(p[i])
 
                  ###
                  alpha <- p[i+ncomp]

                  ###
                  omega <- abs(p[i+2*ncomp])+0.001 

                  ###
                  delta <- alpha/sqrt(1+(alpha)^2)

                  ###
                  v1 <- sqrt(1-2*delta^2/pi)*(4-pi)/4*
                 (delta*sqrt(2/pi))^3/(1-2*delta^2/pi)^1.5

                  ###
                  v2 <- sign(alpha)/2*exp(-2*pi/abs(alpha))

                  ###
                  D <- omega*(sqrt(2/pi)*delta-v1-v2)                

                  ###
                  B[i,] <-  1/sqrt(2*pi)/omega*
                  exp(-0.5*(xd-xm+D)^2/omega^2)*
                 (1+erf(alpha*(xd-xm+D)/sqrt(2)/omega))
                  B[i,] <- B[i,]/sum(B[i,])

              } # end for.

          } else if (model=="skewgnormal0") {

              x0 <- seq(from=0,to=max(xd)/4,by=max(xd)/4/200)

              ###
              for (i in 1:ncomp) {

                  xm <- abs(p[i])

                  ###
                  sigma <- abs(p[i+ncomp])+0.001

                  ###
                  qv <- abs(p[i+2*ncomp])+0.001
                  if (qv>1) qv <- 1

                  ###
                  pv <- 2 + 6*(1-qv)^5

                  ###
                  yf1 <- exp(x0/sigma*qv)
                  yf2 <- exp(x0/sigma/qv)

                  ###
                  y0 <- abs(yf1*qv+yf2/qv)/(yf1+yf2)*
                  exp(-0.5*(abs(log((yf1+yf2)/2)))^pv)
                  if (any(!is.finite(y0)))  return(1e30)  
                        
                  ###            
                  L <- x0[which.max(y0)]

                  ###
                  pf1 <- exp((xd-xm+L)/sigma*qv)
                  pf2 <- exp((xd-xm+L)/sigma/qv)
       
                  ###
                  B[i,] <-  1/(2^(1+1/pv)*sigma*gamma(1+1/pv))*
                  abs(pf1*qv+pf2/qv)/(pf1+pf2)*
                  exp(-0.5*(abs(log(0.5*(pf1+pf2))))^pv)
                  B[i,] <- B[i,]/sum(B[i,])

              } # end for.

          } # end if.

          ###
          BB <- try(solve(B%*%t(B)),silent=TRUE)
          if (class(BB)=="try-error") return(1e30)

          ###
          M <- X %*% t(B) %*% BB 
          M[M<0] <- 0

          ###
          for (i in 1:m) {

              M[i,] <- M[i,]/sum(M[i,])*100

          } # end for.

          ###
          X1 <- M %*% B

          ###
          if (all(is.finite(X)) && all(is.finite(X1))) {

              ###
              Angle <- vector(length=m)

              ###
              for (i in 1:m) {

                  Angle[i] <- abs(acos(sum(X[i,]*X1[i,])/
                              sqrt(sum(X[i,]^2))/
                              sqrt(sum(X1[i,]^2))))*180/pi

              } # end for.

              ###
              return(mean(Angle))      

          } else {

              return(1e30)

          } # end if.

      } # end function minfunc.

      ### 
      ### The function used for calculating matrix M, B, and X1.
      ###-------------------------------------------------------
      calMBX <- function(p,xd,X,model) {

          X <- as.matrix(X)

          ###
          m <- nrow(X)
          n <- ncol(X)

          ###
          if (model %in% c("weibull0","lognormal0")) {

              ncomp <- length(p)/2

          } else if (model %in% c("skewnormal0","skewgnormal0")) {

              ncomp <- length(p)/3

          } # end if.

          ###
          B <- matrix(nrow=ncomp, ncol=n)

          ###
          if (model=="lognormal0") {

              for (i in 1:ncomp) {

                  xm <- abs(p[i])

                  ###
                  sigma <- abs(p[i+ncomp])+0.001
                   
                  ###
                  B[i,] <- 1/sqrt(2*pi)/sigma/xd*
                  exp(-0.5*((log(xd/xm)-sigma^2)/sigma)^2)
                  B[i,] <- B[i,]/sum(B[i,])

              } # end for.

          } else if (model=="weibull0") {

              for (i in 1:ncomp) {

                  xm <- abs(p[i])

                  ###
                  alpha <- abs(p[i+ncomp])+1

                  ###
                  B[i,] <- 1/xm*(alpha-1)*(xd/xm)^(alpha-1)*
                  exp(-(alpha-1)/alpha*(xd/xm)^alpha)
                  B[i,] <- B[i,]/sum(B[i,])

              } # end for.

          } else if (model=="skewnormal0") {

              for (i in 1:ncomp) {

                  xm <- abs(p[i])
 
                  ###
                  alpha <- p[i+ncomp]

                  ###
                  omega <- abs(p[i+2*ncomp])+0.001 

                  ###
                  delta <- alpha/sqrt(1+(alpha)^2)

                  ###
                  v1 <- sqrt(1-2*delta^2/pi)*(4-pi)/4*
                 (delta*sqrt(2/pi))^3/(1-2*delta^2/pi)^1.5

                  ###
                  v2 <- sign(alpha)/2*exp(-2*pi/abs(alpha))

                  ###
                  D <- omega*(sqrt(2/pi)*delta-v1-v2)                

                  ###
                  B[i,] <-  1/sqrt(2*pi)/omega*
                  exp(-0.5*(xd-xm+D)^2/omega^2)*
                 (1+erf(alpha*(xd-xm+D)/sqrt(2)/omega))
                  B[i,] <- B[i,]/sum(B[i,])

              } # end for.

          } else if (model=="skewgnormal0") {

              ###
              x0 <- seq(from=0,to=max(xd)/4,by=max(xd)/4/200)

              ###
              for (i in 1:ncomp) {

                  xm <- abs(p[i])

                  ###
                  sigma <- abs(p[i+ncomp])+0.001

                  ###
                  qv <- abs(p[i+2*ncomp])+0.001
                  if (qv>1) qv <- 1

                  ###
                  pv <- 2 + 6*(1-qv)^5

                  ###
                  yf1 <- exp(x0/sigma*qv)
                  yf2 <- exp(x0/sigma/qv)

                  ###
                  y0 <- abs(yf1*qv+yf2/qv)/(yf1+yf2)*
                  exp(-0.5*(abs(log((yf1+yf2)/2)))^pv)
                       
                  ###             
                  L <- x0[which.max(y0)]

                  ###
                  pf1 <- exp((xd-xm+L)/sigma*qv)
                  pf2 <- exp((xd-xm+L)/sigma/qv)
       
                  ###
                  B[i,] <-  1/(2^(1+1/pv)*sigma*gamma(1+1/pv))*
                  abs(pf1*qv+pf2/qv)/(pf1+pf2)*
                  exp(-0.5*(abs(log(0.5*(pf1+pf2))))^pv)
                  B[i,] <- B[i,]/sum(B[i,])

              } # end for.

          } # end if.

          ###
          M <- X %*% t(B) %*% solve(B%*%t(B)) 
          M[M<0] <- 0

          ###
          for (i in 1:m) {

              M[i,] <- M[i,]/sum(M[i,])*100

          } # end for.

          ###
          X1 <- M %*% B

          ###
          Angle <- R2 <- vector(length=m)

          ###
          for (i in 1:m) {

              Angle[i] <- abs(acos(sum(X[i,]*X1[i,])/
                          sqrt(sum(X[i,]^2))/
                          sqrt(sum(X1[i,]^2))))*180/pi

              ###
              R2[i] <- (sum((X[i,]-mean(X[i,]))*
                       (X1[i,]-mean(X1[i,]))))^2/
                       sum((X[i,]-mean(X[i,]))^2)/
                       sum((X1[i,]-mean(X1[i,]))^2)

          } # end for.

          ###
          list("M"=M, "B"=B, "X1"=X1, "Angle"=Angle, "R2"=R2)

      } # end function calMBX.

      ###
      KMC <- kmeans(X, centers=ncomp, nstart=300)$centers

      ###
      DRV <- matrix(nrow=n, ncol=ncomp)

      ###
      peakLT <- reserveidx0 <- vector(length=ncomp, mode="list")
      CTFV <- vector(length=ncomp)
      
      ###
      for (i in 1:ncomp) {

          DRV[,i] <- tgcd::savgol(KMC[i,], drv=2, hwd=4, pod=2)

          ###
          reserveidx0[[i]] <- which(abs(DRV[,i])>1e-4*max(DRV[,i])) 

          ###
          peakIDX <- pracma::findpeaks(x=-DRV[,i][reserveidx0[[i]]], 
                     minpeakdistance=mpd, sortstr=TRUE)

          ###
          CTFV[i] <- ctf*min(-DRV[,i][reserveidx0[[i]]])

          ###
          peakLT[[i]] <- peakIDX[peakIDX[,1]>CTFV[i],2,drop=TRUE]

      } # end for.

      ###
      reserveidx0t <- sort(union(unlist(reserveidx0),y=NULL))

      ###
      colvec <- c("skyblue", "red", "blue", "plum4", "green", "brown", 
                  "yellow2", "deeppink", "black", "wheat", "grey60", 
                  "turquoise", "magenta1")

      ###
      myTK <- c(0.1,0.2,0.5,1,2,5,10,20,50,100,200,500,1000,2000)
      myLB <- c("0.1","0.2","0.5","1","2","5","10","20","50",
                  "100","200","500","1000","2000")
      ###
      mdgs <- mdgsy <- vector(length=ncomp)

      ###
      for (i in 1:(ncomp+1)) {
           
          matplot(xd[reserveidx0t],t(X[,reserveidx0t]), xaxt="n", yaxt="n", 
                  xlab="",ylab="",type="l", lty=1, col="grey90", log="x",lwd=2)

          ###
          par(new=TRUE)

          ###
          if (i<ncomp+1) { 

              main <- paste("Click the mouse to select ", ncomp, " locations", sep="")

          } else {

              main <- "Structure of grain-size distributions"

          } # end if.

          ###
          matplot(xd[reserveidx0t], DRV[reserveidx0t,], type="l",  
                  lwd=3, lty=1, col=colvec[1:ncomp], xlab="Grain size (um)", 
                  ylab="Second-order derivative", mgp=c(2.5,1,0),main=main,  
                  log="x", cex.axis=1.2, cex.lab=1.5, xaxt="n", cex.main=1.5)

          ###
          box(lwd=2)

          ###
          axis(side=1, at=myTK, labels=myLB, cex.axis=1.2)

          ###
          ###abline(h=-CTFV[i], col="black", lty=2, lwd=4)

          ###
          for (j in 1:ncomp) { 

              abline(v=xd[reserveidx0[[j]]][peakLT[[j]]], col=colvec[j], lwd=2)

          } # end for.

          ###
          if (i>1)  { 

              points(x=mdgs[1:(i-1)], y=mdgsy[1:(i-1)], pch=23, 
                     bg="grey10", col="grey10", cex=1.5)

              ###
              text(x=mdgs[1:(i-1)], y=mdgsy[1:(i-1)], 
                   labels=paste("C",1:(i-1),sep=""), 
                   col="grey10", cex=1.2)

          } # end if.

          ###
          if (i==ncomp+1) break

          ###
          LLL <- try(locator(n=1), silent=TRUE)
          if (class(LLL)=="try-error")  
          stop("Failed in parameter initialisation by clicking!")

          ###
          mdgs[i] <- LLL$x
          mdgsy[i] <- LLL$y

      } # end for.

      ###
      if (useIndex==TRUE) {

          mdgs <- pab[1] + pab[2]*log(mdgs)

      } # end if.

      ###
      if (model %in% c("lognormal0","weibull0")) {

          p0 <- vector(length=2*ncomp)

      } else if (model %in% c("skewnormal0","skewgnormal0")) {

          p0 <- vector(length=3*ncomp)

      } # end if.

      ###
      minVAL <- 1e30
   
      ###
      VAL <- c()

      ###
      cat(paste("model=", model, ", ncomp=", ncomp, ", ntry=", ntry, ".\n", sep="")) 
      cat("Parametric end-member modelling is in progress, please wait, ...\n", sep="") 

      ###
      pb <- txtProgressBar(min=1, max=ntry, initial=1, style=1)

      ###
      for (i in 1:ntry) {

          p0[1:ncomp] <- runif(n=ncomp, min=mdgs*(1-kkf),max=mdgs*(1+kkf))

          ###
          if (model=="lognormal0") {

              if (useIndex==TRUE) {

                  p0[(ncomp+1):(2*ncomp)] <- 0.05

              } else {

                  p0[(ncomp+1):(2*ncomp)] <- 0.5

              } # end if.

          } else if (model=="weibull0") {

              if (useIndex==TRUE) {

                  p0[(ncomp+1):(2*ncomp)] <- runif(n=ncomp,min=6,max=20)

              } else {

                  p0[(ncomp+1):(2*ncomp)] <- runif(n=ncomp,min=2,max=5)

              } # end if.

          } else if (model=="skewnormal0") {

              p0[(ncomp+1):(2*ncomp)] <- 0

              ###
              if (useIndex==TRUE) {

                  p0[(2*ncomp+1):(3*ncomp)] <- 6

              } else {

                  p0[(2*ncomp+1):(3*ncomp)] <- 50

              } # end if.

          } else if (model=="skewgnormal0") {

              if (useIndex==TRUE) {

                  p0[(ncomp+1):(2*ncomp)] <- 5

              } else {

                  p0[(ncomp+1):(2*ncomp)] <- 20

              } # end if.

              ###
              p0[(2*ncomp+1):(3*ncomp)] <- 0.7

          } # end if.

          ###
          OPT <- try(nlminb(start=p0, objective=minfunc, 
                     xd=xd1, X=X, model=model),silent=TRUE)           
          ###if (class(OPT)!="try-error") print(c(i,OPT$objective)) 

          ###
          if (class(OPT)!="try-error") {

              VAL <- rbind(VAL, c(i,OPT$objective))

          } # end if.

          ###
          if (class(OPT)!="try-error" && OPT$objective<minVAL) {

              minVAL <- OPT$objective
                
              ###
              bestOPT <- OPT

          } # end if.

          ###
          setTxtProgressBar(pb, i)

      } # end for.

      ###
      close(pb)

      ###
      if (!exists("bestOPT")) 
      stop("Error: optimization (trial-and-error) failed!")

      ###
      if (model %in% c("lognormal0","weibull0")) {

          pars <- matrix(bestOPT$par,ncol=2)

      } else if (model %in% c("skewnormal0", "skewgnormal0")) {

          pars <- matrix(bestOPT$par,ncol=3)

      } # end if.

      ###
      pars[,1] <- abs(pars[,1])

      ###
      MBX <- calMBX(p=c(pars[order(pars[,1]),,drop=FALSE]),xd1,X,model=model) 

      ###
      abundance <- MBX$M
      endmember <- MBX$B
      fitGSD <- MBX$X1 
      Angle <- MBX$Angle
      meanAngle <- mean(Angle)
      sdmeanAngle <- sd(Angle)/sqrt(m)
      R2 <- MBX$R2
      meanR2 <- mean(R2)
      sdmeanR2 <- sd(R2)/sqrt(m)

      ###
      if (model=="lognormal0") {

          pars[,2] <- abs(pars[,2])+0.001

          ###
          colnames(pars) <- c("xm0","sigma")

      } else if (model=="weibull0") {

          pars[,2] <- abs(pars[,2])+1

          ###
          colnames(pars) <- c("xm0","alpha")

      } else if (model=="skewnormal0") {

          pars[,3] <- abs(pars[,3])+0.001 

          ###
          colnames(pars) <- c("xm0", "alpha","omega")

      } else if (model=="skewgnormal0") {

          pars[,2] <- abs(pars[,2])+0.001

          ###
          pars[,3] <- abs(pars[,3])+0.001
          if (any(pars[,3]>1)) pars[pars[,3]>1,3] <- 1

          ###
          colnames(pars) <- c("xm0", "sigma","q")

      } # end if.

      ###
      rownames(pars) <- paste("EM.",1:ncomp,sep="")

      ###
      pars <- pars[order(pars[,1]),,drop=FALSE]
     
      ###
      if (useIndex==TRUE) {

          xm <- exp((pars[,1,drop=TRUE]-pab[1])/pab[2])

      } else {

          xm <- pars[,1,drop=TRUE]

      } # end if.

      ###
      if (csv==TRUE) {

          ###
          FL1 <- cbind(1:m, Angle, R2, abundance)
          colnames(FL1) <- c("NO","Angle","R2",paste("EM.",1:ncomp,sep=""))

          ###
          FL2 <- cbind(xd,t(endmember))
          colnames(FL2) <- c("GS",paste("EM.",1:ncomp,sep=""))

          ###
          WFL1 <- try(write.csv(FL1, file="abundance.csv"),silent=TRUE)
          if (class(WFL1)=="try-error") cat("Note: write to [abundance.csv] failed!\n")

          ###
          WFL2 <- try(write.csv(FL2, file="endmember.csv"),silent=TRUE)
          if (class(WFL2)=="try-error") cat("Note: write to [endmember.csv] failed!\n")

      } # end if.

      ###
      if (!is.null(pdfname)) {

          PDF <- try(pdf(paste(pdfname,".pdf",sep="")),silent=TRUE)
          if (class(PDF)=="try-error") cat("Note: write to PDF failed!\n") 

          ### The summary.
          ###------------------------------------
          par(mfrow=c(1,1))
          par(mar=c(2.1, 2.1, 4.1, 2.1))

          ###
          plot(1,1,type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="", 
               main="Summary of results", cex.main=2)

          ###
          mylegend <- c(paste("Number of single-sample GSDs:  ", m, sep=""), "",
                        paste("End-member model: ", model, sep=""), 
                        paste("Number of endmembers: ", ncomp, sep=""), 
                        paste("Number of random trials: ", ntry, sep=""),"",
                        paste("Mean angle (St. Dev.):    ", 
                              round(meanAngle,2)," (",round(sdmeanAngle,2),")", sep=""), 
                        paste("Mean R2 (St. Dev.):       ", 
                              round(meanR2,2), " (",round(sdmeanR2,2),")", sep=""), "",
                        paste("Mode of EM.1:  ", round(xm[1],2), " um", sep=""),
                        paste("Mode of EM.2:  ", round(xm[2],2), " um", sep=""),
                        paste("Mode of EM.3:  ", round(xm[3],2), " um", sep=""),
                        paste("Mode of EM.4:  ", round(xm[4],2), " um", sep=""),
                        paste("Mode of EM.5:  ", round(xm[5],2), " um", sep=""),
                        paste("Mode of EM.6:  ", round(xm[6],2), " um", sep=""),
                        paste("Mode of EM.7:  ", round(xm[7],2), " um", sep=""),
                        paste("Mode of EM.8:  ", round(xm[8],2), " um", sep=""),
                        paste("Mode of EM.9:  ", round(xm[9],2), " um", sep=""))

          ###
          legend("top",legend=mylegend[1:(9+ncomp)], bty="n", cex=1.25)

          ###
          ### The first plot.
          ###------------------------------------
          par(mar=c(7.1, 6.1, 6.1, 4.1))
          plot(VAL, type="p", xlab="Index of random trials", ylab="Optimized angle (Degree)",
               mgp=c(2.3,1,0), cex=2, pch=21, bg="skyblue", cex.axis=1.2, cex.lab=1.5, cex.main=1.5)

          ###
          points(VAL, type="s", lwd=1.6, col="skyblue")

          ###
          box(lwd=2)

          ###
          ### The second plot.
          ###------------------------------------
          par(mar=c(7.1, 6.1, 6.1, 4.1))

          ###
          matplot(xd, t(endmember), type="l", lwd=3, lty=1, col=colvec[1:ncomp], 
                  xlab="Grain size (um)", ylab="Probability density", mgp=c(2.3,1,0), 
                  log="x", cex.axis=1.2, cex.lab=1.5, cex.main=1.5,xaxt="n")

          ###
          box(lwd=2)

          ###
          axis(side=1, at=myTK, labels=myLB, cex.axis=1.2)

          ###
          legend("topleft", legend=paste("EM.",1:ncomp,sep=""), 
                 col=colvec[1:ncomp],lwd=2, bty="n")

          ###
          ### The third plot.
          ###------------------------------------
          layout(matrix(c(1,2,3,4),nrow=2, byrow=TRUE), respect=TRUE)
          par(mar=c(4.1, 4.1, 2.1, 2.1))

          ### 
          matplot(xd, t(X), log="x", type="l", lty=1, xlab="Grain size (um)", 
                  ylab="Measured volume percentage (%)", col="red", lwd=1.25, 
                  mgp=c(2.3,1,0), cex.axis=1.25, cex.lab=1.25, xaxt="n")
          axis(side=1, at=myTK, labels=myLB, cex.axis=1.2)

          ### 
          matplot(xd, t(fitGSD), log="x", type="l", lty=1, xlab="Grain size (um)", 
                  ylab="Predicted volume percentage (%)", col="skyblue", lwd=1.25, 
                  mgp=c(2.3,1,0), cex.axis=1.25, cex.lab=1.25, xaxt="n")
          axis(side=1, at=myTK, labels=myLB, cex.axis=1.2)

          ### 
          plot(1:m, Angle, type="p", lty=1, xlab="Sample index", 
               ylab="Optimized angle (Degree)", col="brown", lwd=3, 
               mgp=c(2.3,1,0), cex.axis=1.25, cex.lab=1.25)
          abline(h=meanAngle, col="red", lty=2, lwd=2)

          ### 
          plot(1:m, R2, type="p", lty=1, xlab="Sample index", ylab="Optimized R2", 
               col="purple", lwd=3, mgp=c(2.3,1,0), cex.axis=1.25, cex.lab=1.25)
          abline(h=meanR2, col="red", lty=2, lwd=2)

          ###
          ### The fourth plot.
          ###-------------------------------------
          layout(matrix(seq(nr*nc),nrow=nr, ncol=nc, byrow=TRUE), respect=TRUE)
          par(mar=c(0.3,0.3,0.3,0.3))

          ### 
          for (i in 1:m) {
 
            ###
            matplot(xd,cbind(X[i,],fitGSD[i,]), type="l", lty=1, 
                    lwd=2, log="x", xaxt="n", yaxt="n", bty="n",  
                    col=c("red","skyblue"))

            ###
            legend("topleft", legend=c(paste("NO=",i,sep=""),
                   paste("Angle=",round(Angle[i],2),sep=""),
                   paste("R2=",round(R2[i],2),sep="")),
                   bty="n",cex=0.5)

            ###
            box(lwd=3)

        } # end for.
               
          ###  
          dev.off()
          
      } # end if.

      ### 
      output <- list("fitGSD"=fitGSD, "abundance"=abundance, "endmember"=endmember, 
                     "Angle"=Angle, "meanAngle"=meanAngle, "sdmeanAngle"=sdmeanAngle, 
                     "R2"=R2, "meanR2"=meanR2, "sdmeanR2"=sdmeanR2, "pars"=pars, "xm"=xm)

      ###
      invisible(output)

  } # end function PEMM.
  ###

    
  ###
  ###***********************************************************************************
  ### Users may also need to install and load the following external R package if 
  ### they want to use a parallel version of the R function PEMM(), i.e., PEMMp().
  ###===================================================================================
  library(parallel)
  ###
  library(foreach)
  ###
  library(snow)
  ###
  library(doSNOW)
  ###=========================================================================================

  ###
  ###**************************************************************************************************************************
  ### Function PEMMp() is a parallel version of the R function PEMM(). 
  ###==========================================================================================================================
  ### The function contains the following arguments.
  ###
  ###    GSDmat: A matrix storing the grain-size data used for analysis. The first row is 
  ###            the grain-size levels, and the remaining rows are the volume percentages 
  ###            of individual samples to be modelled. 
  ###
  ###     ncomp: An integer (from 1 to 13) indicating the number of endmembers to be modelled. 
  ###
  ###     model: A character indicating the model to be fitted,
  ###            "weibull0", "lognormal0", "skewnormal0", or "skewgnormal0".
  ###
  ###       mpd: An integer indicating the minimum distance (in indices) of peaks to be identified.
  ###
   ###      ctf: A numeric value (between -1 and 1) representing a critical threshold   
  ###            that controls the identification of peaks from the grain-size distribution.  
  ###            This argument can be used to prevent identifying a false peak characterised  
  ###            by a large positive second-order derivative. Specially, ctf=0 indicates 
  ###            peaks with second-order derivatives above zero will be precluded.  
  ###            The degree of precluding will be increasingly suppressed as ctf 
  ###            increases from -1 to 1.          
  ###
  ###      ntry: An integer indicating the number of trials in a trial-and-error protocol. 
  ###
  ###       kkf: A numeric value controlling the range of values from which random starting   
  ###            parameters will be generated during the "trial-and-error" protocol.
  ###
  ###  useIndex: A logical value indicating whether the index of a grain-size level will be  
  ###            used as the independent variable during the modelling process.
  ###
  ###       ncr: The number of cores to be used during the parallel unmixing process. If
  ###            the total number of available cores (NumberOfCluster) is smaller than ncr, 
  ###            NumberOfCluster will be used instead of ncr.
  ###
  ###       csv: A logical value indicating if the output results will be saved in CSV files. 
  ###
  ###   pdfname: A character indicating the name of the PDF file the modelling results will  
  ###            be written to. The results will not be returned to a PDF file if pdfname=NULL.
  ###
  ###        nr: An integer indicating the number of rows generated in the PDF file.
  ###
  ###        nc: An integer indicating the number of columns generated in the PDF file.
  ###==========================================================================================================================
  ### The function returns an invisible list containing the following elements.
  ###
  ###      fitGSD: A matrix containing the fitted/predicted grain-size distributions.
  ###
  ###   abundance: A matrix containing the abundances of grain-size distributions.
  ###
  ###   endmember: A matrix containing the optimized parametric endmembers.
  ###
  ###       Angle: A vector containing the minimized angles between measured and predicted 
  ###              grain-size distributions.
  ###
  ###   meanAngle: A numerical value indicating the mean of the minimized angles.
  ###
  ### sdmeanAngle: A numerical value indicating the standard deviation of the mean of the 
  ###              minimized angles.
  ###
  ###          R2: A vector containing the squared correlation coefficients bettwen measured 
  ###              and predicted grain-size distributions.
  ###
  ###      meanR2: A numerical value indicating the mean of the squared correlation coefficients.
  ### 
  ###    sdmeanR2: A numerical value indicating the standard deviation of the mean of the squared
  ###              correlation coefficients.
  ###
  ###        pars: A matrix containing the optimized parameters describing parametric endmembers.
  ###
  ###          xm: A vector containg the optimized modes of endmembers.
  ###==========================================================================================================================
  ### In addition, the function automatically writes the results to CSV files (i.e., "abundance.csv",
  ### "endmember.csv") if csv=TRUE and generates a plot sumamrying the results if pdfname!=NULL.
  ###==========================================================================================================================
  PEMMp <- function(GSDmat, ncomp, model="weibull0", mpd=3, ctf=-0.1, 
                    ntry=50, kkf=0.2, useIndex=TRUE, ncr=NULL, csv=TRUE, 
                    pdfname=NULL, nr=10, nc=9) {

      GSDmat <- as.matrix(GSDmat)

      ###
      if(nrow(GSDmat)<2) 
      stop("Error: [GSDmat] should contain at least two rows!")

      ###
      stopifnot(length(ncomp)==1, is.numeric(ncomp), ncomp %in% 1:13,
                is.character(model), length(model)==1, 
                model %in% c("weibull0","lognormal0","skewnormal0","skewgnormal0"),
                is.numeric(mpd), length(mpd)==1, mpd>0,
                is.numeric(ctf), length(ctf)==1, ctf>=-1, ctf<=1,
                is.numeric(ntry), length(ntry)==1, ntry>=2, 
                is.numeric(kkf), length(kkf)==1, kkf>0, kkf<1,
                is.logical(useIndex), length(useIndex)==1,
                is.null(ncr) || is.numeric(ncr),
                is.logical(csv), length(csv)==1,
                is.null(pdfname) || (is.character(pdfname) && length(pdfname)==1),
                is.numeric(nr), length(nr)==1, nr>0, 
                is.numeric(nc), length(nc)==1, nc>0)
        
      ###
      X <- GSDmat[-1,,drop=FALSE]

      ###
      m <- nrow(X)
      n <- ncol(X)

      ###
      xd <- as.numeric(GSDmat[1,])

      if (useIndex==TRUE) {

          xd1 <- seq(n)

          ###
          pab <- as.numeric(lm(xd1~log(xd))$coefficients)

      } else {

          xd1 <- xd

      } # end if.

      ### 
      ### The error function.
      ###---------------------
      erf <- function(x) { 2 * pnorm(x * sqrt(2)) - 1 }

      ###
      ### The function to be minimized.
      ###-------------------------------------
      minfunc <- function(p,xd,X,model) {

          X <- as.matrix(X)

          ###
          m <- nrow(X)
          n <- ncol(X)

          ###
          ###
          if (model %in% c("weibull0","lognormal0")) {

              ncomp <- length(p)/2

          } else if (model %in% c("skewnormal0","skewgnormal0")) {

              ncomp <- length(p)/3

          } # end if.

          ###
          B <- matrix(nrow=ncomp, ncol=n)

          ###
          if (model=="lognormal0") {

              for (i in 1:ncomp) {

                  xm <- abs(p[i])

                  ###
                  sigma <- abs(p[i+ncomp])+0.001
                   
                  ###
                  B[i,] <- 1/sqrt(2*pi)/sigma/xd*
                  exp(-0.5*((log(xd/xm)-sigma^2)/sigma)^2)
                  B[i,] <- B[i,]/sum(B[i,])

              } # end for.

          } else if (model=="weibull0") {

              for (i in 1:ncomp) {

                  xm <- abs(p[i])

                  ###
                  alpha <- abs(p[i+ncomp])+1

                  ###
                  B[i,] <- 1/xm*(alpha-1)*(xd/xm)^(alpha-1)*
                  exp(-(alpha-1)/alpha*(xd/xm)^alpha)
                  B[i,] <- B[i,]/sum(B[i,])

              } # end for.

          } else if (model=="skewnormal0") {

              for (i in 1:ncomp) {

                  xm <- abs(p[i])
 
                  ###
                  alpha <- p[i+ncomp]

                  ###
                  omega <- abs(p[i+2*ncomp])+0.001 

                  ###
                  delta <- alpha/sqrt(1+(alpha)^2)

                  ###
                  v1 <- sqrt(1-2*delta^2/pi)*(4-pi)/4*
                 (delta*sqrt(2/pi))^3/(1-2*delta^2/pi)^1.5

                  ###
                  v2 <- sign(alpha)/2*exp(-2*pi/abs(alpha))

                  ###
                  D <- omega*(sqrt(2/pi)*delta-v1-v2)                

                  ###
                  B[i,] <-  1/sqrt(2*pi)/omega*
                  exp(-0.5*(xd-xm+D)^2/omega^2)*
                 (1+erf(alpha*(xd-xm+D)/sqrt(2)/omega))
                  B[i,] <- B[i,]/sum(B[i,])

              } # end for.

          } else if (model=="skewgnormal0") {

              x0 <- seq(from=0,to=max(xd)/4,by=max(xd)/4/200)

              ###
              for (i in 1:ncomp) {

                  xm <- abs(p[i])

                  ###
                  sigma <- abs(p[i+ncomp])+0.001

                  ###
                  qv <- abs(p[i+2*ncomp])+0.001
                  if (qv>1) qv <- 1

                  ###
                  pv <- 2 + 6*(1-qv)^5

                  ###
                  yf1 <- exp(x0/sigma*qv)
                  yf2 <- exp(x0/sigma/qv)

                  ###
                  y0 <- abs(yf1*qv+yf2/qv)/(yf1+yf2)*
                  exp(-0.5*(abs(log((yf1+yf2)/2)))^pv)
                  if (any(!is.finite(y0)))  return(1e30)  
                        
                  ###            
                  L <- x0[which.max(y0)]

                  ###
                  pf1 <- exp((xd-xm+L)/sigma*qv)
                  pf2 <- exp((xd-xm+L)/sigma/qv)
       
                  ###
                  B[i,] <-  1/(2^(1+1/pv)*sigma*gamma(1+1/pv))*
                  abs(pf1*qv+pf2/qv)/(pf1+pf2)*
                  exp(-0.5*(abs(log(0.5*(pf1+pf2))))^pv)
                  B[i,] <- B[i,]/sum(B[i,])

              } # end for.

          } # end if.

          ###
          BB <- try(solve(B%*%t(B)),silent=TRUE)
          if (class(BB)=="try-error") return(1e30)

          ###
          M <- X %*% t(B) %*% BB 
          M[M<0] <- 0

          ###
          for (i in 1:m) {

              M[i,] <- M[i,]/sum(M[i,])*100

          } # end for.

          ###
          X1 <- M %*% B

          ###
          if (all(is.finite(X)) && all(is.finite(X1))) {

              ###
              Angle <- vector(length=m)

              ###
              for (i in 1:m) {

                  Angle[i] <- abs(acos(sum(X[i,]*X1[i,])/
                              sqrt(sum(X[i,]^2))/
                              sqrt(sum(X1[i,]^2))))*180/pi

              } # end for.

              ###
              return(mean(Angle))      

          } else {

              return(1e30)

          } # end if.

      } # end function minfunc.

      ### 
      ### The function used for calculating matrix M, B, and X1.
      ###-------------------------------------------------------
      calMBX <- function(p,xd,X,model) {

          X <- as.matrix(X)

          ###
          m <- nrow(X)
          n <- ncol(X)

          ###
          if (model %in% c("weibull0","lognormal0")) {

              ncomp <- length(p)/2

          } else if (model %in% c("skewnormal0","skewgnormal0")) {

              ncomp <- length(p)/3

          } # end if.

          ###
          B <- matrix(nrow=ncomp, ncol=n)

          ###
          if (model=="lognormal0") {

              for (i in 1:ncomp) {

                  xm <- abs(p[i])

                  ###
                  sigma <- abs(p[i+ncomp])+0.001
                   
                  ###
                  B[i,] <- 1/sqrt(2*pi)/sigma/xd*
                  exp(-0.5*((log(xd/xm)-sigma^2)/sigma)^2)
                  B[i,] <- B[i,]/sum(B[i,])

              } # end for.

          } else if (model=="weibull0") {

              for (i in 1:ncomp) {

                  xm <- abs(p[i])

                  ###
                  alpha <- abs(p[i+ncomp])+1

                  ###
                  B[i,] <- 1/xm*(alpha-1)*(xd/xm)^(alpha-1)*
                  exp(-(alpha-1)/alpha*(xd/xm)^alpha)
                  B[i,] <- B[i,]/sum(B[i,])

              } # end for.

          } else if (model=="skewnormal0") {

              for (i in 1:ncomp) {

                  xm <- abs(p[i])
 
                  ###
                  alpha <- p[i+ncomp]

                  ###
                  omega <- abs(p[i+2*ncomp])+0.001 

                  ###
                  delta <- alpha/sqrt(1+(alpha)^2)

                  ###
                  v1 <- sqrt(1-2*delta^2/pi)*(4-pi)/4*
                 (delta*sqrt(2/pi))^3/(1-2*delta^2/pi)^1.5

                  ###
                  v2 <- sign(alpha)/2*exp(-2*pi/abs(alpha))

                  ###
                  D <- omega*(sqrt(2/pi)*delta-v1-v2)                

                  ###
                  B[i,] <-  1/sqrt(2*pi)/omega*
                  exp(-0.5*(xd-xm+D)^2/omega^2)*
                 (1+erf(alpha*(xd-xm+D)/sqrt(2)/omega))
                  B[i,] <- B[i,]/sum(B[i,])

              } # end for.

          } else if (model=="skewgnormal0") {

              ###
              x0 <- seq(from=0,to=max(xd)/4,by=max(xd)/4/200)

              ###
              for (i in 1:ncomp) {

                  xm <- abs(p[i])

                  ###
                  sigma <- abs(p[i+ncomp])+0.001

                  ###
                  qv <- abs(p[i+2*ncomp])+0.001
                  if (qv>1) qv <- 1

                  ###
                  pv <- 2 + 6*(1-qv)^5

                  ###
                  yf1 <- exp(x0/sigma*qv)
                  yf2 <- exp(x0/sigma/qv)

                  ###
                  y0 <- abs(yf1*qv+yf2/qv)/(yf1+yf2)*
                  exp(-0.5*(abs(log((yf1+yf2)/2)))^pv)
                       
                  ###             
                  L <- x0[which.max(y0)]

                  ###
                  pf1 <- exp((xd-xm+L)/sigma*qv)
                  pf2 <- exp((xd-xm+L)/sigma/qv)
       
                  ###
                  B[i,] <-  1/(2^(1+1/pv)*sigma*gamma(1+1/pv))*
                  abs(pf1*qv+pf2/qv)/(pf1+pf2)*
                  exp(-0.5*(abs(log(0.5*(pf1+pf2))))^pv)
                  B[i,] <- B[i,]/sum(B[i,])

              } # end for.

          } # end if.

          ###
          M <- X %*% t(B) %*% solve(B%*%t(B)) 
          M[M<0] <- 0

          ###
          for (i in 1:m) {

              M[i,] <- M[i,]/sum(M[i,])*100

          } # end for.

          ###
          X1 <- M %*% B

          ###
          Angle <- R2 <- vector(length=m)

          ###
          for (i in 1:m) {

              Angle[i] <- abs(acos(sum(X[i,]*X1[i,])/
                          sqrt(sum(X[i,]^2))/
                          sqrt(sum(X1[i,]^2))))*180/pi

              ###
              R2[i] <- (sum((X[i,]-mean(X[i,]))*
                       (X1[i,]-mean(X1[i,]))))^2/
                       sum((X[i,]-mean(X[i,]))^2)/
                       sum((X1[i,]-mean(X1[i,]))^2)

          } # end for.

          ###
          list("M"=M, "B"=B, "X1"=X1, "Angle"=Angle, "R2"=R2)

      } # end function calMBX.

      ###
      KMC <- kmeans(X, centers=ncomp, nstart=300)$centers

      ###
      DRV <- matrix(nrow=n, ncol=ncomp)

      ###
      peakLT <- reserveidx0 <- vector(length=ncomp, mode="list")
      CTFV <- vector(length=ncomp)

      ###
      for (i in 1:ncomp) {

          DRV[,i] <- tgcd::savgol(KMC[i,], drv=2, hwd=4, pod=2)

          ###
          reserveidx0[[i]] <- which(abs(DRV[,i])>1e-4*max(DRV[,i])) 

          ###
          peakIDX <- pracma::findpeaks(x=-DRV[,i][reserveidx0[[i]]], 
                     minpeakdistance=mpd, sortstr=TRUE)

          ###
          CTFV[i] <- ctf*min(-DRV[,i][reserveidx0[[i]]])

          ###
          peakLT[[i]] <- peakIDX[peakIDX[,1]>CTFV[i],2,drop=TRUE]

      } # end for.

      ###
      reserveidx0t <- sort(union(unlist(reserveidx0),y=NULL))

      ###
      colvec <- c("skyblue", "red", "blue", "plum4", "green", "brown", 
                  "yellow2", "deeppink", "black", "wheat", "grey60", 
                  "turquoise", "magenta1")

      ###
      myTK <- c(0.1,0.2,0.5,1,2,5,10,20,50,100,200,500,1000,2000)
      myLB <- c("0.1","0.2","0.5","1","2","5","10","20","50",
                  "100","200","500","1000","2000")
      ###
      mdgs <- mdgsy <- vector(length=ncomp)

      ###
      for (i in 1:(ncomp+1)) {
           
          matplot(xd[reserveidx0t],t(X[,reserveidx0t]), xaxt="n", yaxt="n", 
                  xlab="",ylab="",type="l", lty=1, col="grey90", log="x",lwd=2)

          ###
          par(new=TRUE)

          ###
          if (i<ncomp+1) { 

              main <- paste("Click the mouse to select ", ncomp, " locations", sep="")

          } else {

              main <- "Structure of grain-size distributions"

          } # end if.

          ###
          matplot(xd[reserveidx0t], DRV[reserveidx0t,], type="l",  
                  lwd=3, lty=1, col=colvec[1:ncomp], xlab="Grain size (um)", 
                  ylab="Second-order derivative", mgp=c(2.5,1,0),main=main,  
                  log="x", cex.axis=1.2, cex.lab=1.5, xaxt="n", cex.main=1.5)

          ###
          box(lwd=2)

          ###
          axis(side=1, at=myTK, labels=myLB, cex.axis=1.2)

          ###
          ###abline(h=-CTFV[i], col="black", lty=2, lwd=4)

          ###
          for (j in 1:ncomp) { 

              abline(v=xd[reserveidx0[[j]]][peakLT[[j]]], col=colvec[j], lwd=2)

          } # end for.

          ###
          if (i>1)  { 

              points(x=mdgs[1:(i-1)], y=mdgsy[1:(i-1)], pch=23, 
                     bg="grey10", col="grey10", cex=1.5)

              ###
              text(x=mdgs[1:(i-1)], y=mdgsy[1:(i-1)], 
                   labels=paste("C",1:(i-1),sep=""), 
                   col="grey10", cex=1.2)

          } # end if.

          ###
          if (i==ncomp+1) break

          ###
          LLL <- try(locator(n=1), silent=TRUE)
          if (class(LLL)=="try-error")  
          stop("Failed in parameter initialisation by clicking!")

          ###
          mdgs[i] <- LLL$x
          mdgsy[i] <- LLL$y

      } # end for.

      ###
      if (useIndex==TRUE) {

          mdgs <- pab[1] + pab[2]*log(mdgs)

      } # end if.

      ###
      if (model %in% c("lognormal0","weibull0")) {

          p0 <- vector(length=2*ncomp)

      } else if (model %in% c("skewnormal0","skewgnormal0")) {

          p0 <- vector(length=3*ncomp)

      } # end if.

      ###
      minVAL <- 1e30
   
      ###
      if (ntry<10)
      stop("Error: Parallel optimisation is forbidden for ntry<10!")

      ###
      NumberOfCluster <- parallel::detectCores()

      ###
      if (!is.null(ncr)) {

          if (!ncr %in% (2:100)) 
          stop("Error: [ncr] must be an integer ranging from 2 to 100!")

          ###
          if (ncr<=NumberOfCluster) {

              NumberOfCluster <- ncr

          } else {

              cat("Note: [ncr=",ncr,"] exceeds the number of available cores (",
              NumberOfCluster,")!\n",sep="")

          } # end if.

      } # end if.
               
      ###
      cl <- snow::makeCluster(NumberOfCluster, outfile="")
      doSNOW::registerDoSNOW(cl)

      ###
      cat(paste("model=", model, ", ncomp=", ncomp, ", ntry=", ntry, ".\n", sep="")) 
      cat("Parametric end-member modelling is in progress, please wait, ...\n", sep="") 

      ###
      pb <- txtProgressBar(max=ntry, style=3)
      progress <- function(n) setTxtProgressBar(pb, n)
      opts <- list(progress=progress)

      ###
      optPEMM <- foreach::foreach(i=1:ntry, .inorder=TRUE,  
                 .options.snow=opts, .verbose=FALSE) %dopar% { 

          p0[1:ncomp] <- runif(n=ncomp, min=mdgs*(1-kkf),max=mdgs*(1+kkf))

          ###
          if (model=="lognormal0") {

              if (useIndex==TRUE) {

                  p0[(ncomp+1):(2*ncomp)] <- 0.05

              } else {

                  p0[(ncomp+1):(2*ncomp)] <- 0.5

              } # end if.

          } else if (model=="weibull0") {

              if (useIndex==TRUE) {

                  p0[(ncomp+1):(2*ncomp)] <- runif(n=ncomp,min=6,max=20)

              } else {

                  p0[(ncomp+1):(2*ncomp)] <- runif(n=ncomp,min=2,max=5)

              } # end if.

          } else if (model=="skewnormal0") {

              p0[(ncomp+1):(2*ncomp)] <- 0

              ###
              if (useIndex==TRUE) {

                  p0[(2*ncomp+1):(3*ncomp)] <- 6

              } else {

                  p0[(2*ncomp+1):(3*ncomp)] <- 50

              } # end if.

          } else if (model=="skewgnormal0") {

              if (useIndex==TRUE) {

                  p0[(ncomp+1):(2*ncomp)] <- 5

              } else {

                  p0[(ncomp+1):(2*ncomp)] <- 20

              } # end if.

              ###
              p0[(2*ncomp+1):(3*ncomp)] <- 0.7

          } # end if.

          ###
          OPT <- try(nlminb(start=p0, objective=minfunc, 
                     xd=xd1, X=X, model=model),silent=TRUE)

          ###
          return(OPT)

      } # end for.

      ###
      cat("\n")
      close(pb)

      ###
      foreach::registerDoSEQ()
      snow::stopCluster(cl)

      ### Prepare for output.
      ###-------------------------------------------------------------------------------------
      OKidx <- which(sapply(optPEMM, function(x) class(x)!="try-error"))

      ###
      if (length(OKidx)<1) 
      stop("Error: optimization (trial-and-error) failed!")

      ###
      VAL <- sapply(optPEMM[OKidx], function(x)  x$objective)
      idx <- order(VAL)
        
      ###
      pars <- optPEMM[[idx[1]]]$par

      ###
      if (model %in% c("lognormal0","weibull0")) {

          pars <- matrix(pars,ncol=2)

      } else if (model %in% c("skewnormal0", "skewgnormal0")) {

          pars <- matrix(pars,ncol=3)

      } # end if.

      ###
      pars[,1] <- abs(pars[,1])

      ###
      MBX <- calMBX(p=c(pars[order(pars[,1]),,drop=FALSE]),xd1,X,model=model) 

      ###
      abundance <- MBX$M
      endmember <- MBX$B
      fitGSD <- MBX$X1 
      Angle <- MBX$Angle
      meanAngle <- mean(Angle)
      sdmeanAngle <- sd(Angle)/sqrt(m)
      R2 <- MBX$R2
      meanR2 <- mean(R2)
      sdmeanR2 <- sd(R2)/sqrt(m)
       
      ###
      if (model=="lognormal0") {

          pars[,2] <- abs(pars[,2])+0.001

          ###
          colnames(pars) <- c("xm0","sigma")

      } else if (model=="weibull0") {

          pars[,2] <- abs(pars[,2])+1

          ###
          colnames(pars) <- c("xm0","alpha")

      } else if (model=="skewnormal0") {

          pars[,3] <- abs(pars[,3])+0.001 

          ###
          colnames(pars) <- c("xm0", "alpha","omega")

      } else if (model=="skewgnormal0") {

          pars[,2] <- abs(pars[,2])+0.001

          ###
          pars[,3] <- abs(pars[,3])+0.001
          if (any(pars[,3]>1)) pars[pars[,3]>1,3] <- 1

          ###
          colnames(pars) <- c("xm0", "sigma","q")

      } # end if.

      ###
      rownames(pars) <- paste("EM.",1:ncomp,sep="")

      ###
      pars <- pars[order(pars[,1]),,drop=FALSE]

      ###
      if (useIndex==TRUE) {

          xm <- exp((pars[,1,drop=TRUE]-pab[1])/pab[2])

      } else {

          xm <- pars[,1,drop=TRUE]

      } # end if.

      ###
      if (csv==TRUE) {

          ###
          FL1 <- cbind(1:m, Angle, R2, abundance)
          colnames(FL1) <- c("NO","Angle","R2",paste("EM.",1:ncomp,sep=""))

          ###
          FL2 <- cbind(xd,t(endmember))
          colnames(FL2) <- c("GS",paste("EM.",1:ncomp,sep=""))

          ###
          WFL1 <- try(write.csv(FL1, file="abundance.csv"),silent=TRUE)
          if (class(WFL1)=="try-error") cat("Note: write [abundance.csv] failed!\n")

          ###
          WFL2 <- try(write.csv(FL2, file="endmember.csv"),silent=TRUE)
          if (class(WFL2)=="try-error") cat("Note: write [endmember.csv] failed!\n")

      } # end if.

      ###
      if (!is.null(pdfname)) {

          PDF <- try(pdf(paste(pdfname,".pdf",sep="")),silent=TRUE)
          if (class(PDF)=="try-error") cat("Note: write to PDF failed!\n") 

          ### The summary.
          ###------------------------------------
          par(mfrow=c(1,1))
          par(mar=c(2.1, 2.1, 4.1, 2.1))

          ###
          plot(1,1,type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="", 
               main="Summary of results", cex.main=2)

          ###
          mylegend <- c(paste("Number of single-sample GSDs:  ", m, sep=""), "",
                        paste("End-member model: ", model, sep=""), 
                        paste("Number of endmembers: ", ncomp, sep=""), 
                        paste("Number of random trials: ", ntry, sep=""),"",
                        paste("Mean angle (St. Dev.):    ", 
                              round(meanAngle,2)," (",round(sdmeanAngle,2),")", sep=""), 
                        paste("Mean R2 (St. Dev.):       ", 
                              round(meanR2,2), " (",round(sdmeanR2,2),")", sep=""), "",
                        paste("Mode of EM.1:  ", round(xm[1],2), " um", sep=""),
                        paste("Mode of EM.2:  ", round(xm[2],2), " um", sep=""),
                        paste("Mode of EM.3:  ", round(xm[3],2), " um", sep=""),
                        paste("Mode of EM.4:  ", round(xm[4],2), " um", sep=""),
                        paste("Mode of EM.5:  ", round(xm[5],2), " um", sep=""),
                        paste("Mode of EM.6:  ", round(xm[6],2), " um", sep=""),
                        paste("Mode of EM.7:  ", round(xm[7],2), " um", sep=""),
                        paste("Mode of EM.8:  ", round(xm[8],2), " um", sep=""),
                        paste("Mode of EM.9:  ", round(xm[9],2), " um", sep=""))

          ###
          legend("top",legend=mylegend[1:(9+ncomp)], bty="n", cex=1.25)

          ###
          ### The first plot.
          ###------------------------------------
          par(mar=c(7.1, 6.1, 6.1, 4.1))
          plot(OKidx, VAL, type="p", xlab="Index of random trials", ylab="Optimized angle (Degree)",
               mgp=c(2.3,1,0), cex=2, pch=21, bg="skyblue", cex.axis=1.2, cex.lab=1.5, cex.main=1.5)

          ###
          points(OKidx, VAL, type="s", lwd=1.6, col="skyblue")
   
          ###
          box(lwd=2)
          
          ###
          ### The second plot.
          ###------------------------------------
          par(mar=c(7.1, 6.1, 6.1, 4.1))

          ###
          matplot(xd, t(endmember), type="l", lwd=3, lty=1, col=colvec[1:ncomp], 
                  xlab="Grain size (um)", ylab="Probability density", mgp=c(2.3,1,0), 
                  log="x", cex.axis=1.2, cex.lab=1.5, cex.main=1.5,xaxt="n")

          ###
          box(lwd=2)

          ###
          axis(side=1, at=myTK, labels=myLB, cex.axis=1.2)

          ###
          legend("topleft", legend=paste("EM.",1:ncomp,sep=""), 
                 col=colvec[1:ncomp],lwd=2, bty="n")

          ###
          ### The third plot.
          ###------------------------------------
          layout(matrix(c(1,2,3,4),nrow=2, byrow=TRUE), respect=TRUE)
          par(mar=c(4.1, 4.1, 2.1, 2.1))

          ### 
          matplot(xd, t(X), log="x", type="l", lty=1, xlab="Grain size (um)", 
                  ylab="Measured volume percentage (%)", col="red", lwd=1.25, 
                  mgp=c(2.3,1,0), cex.axis=1.25, cex.lab=1.25, xaxt="n")
          axis(side=1, at=myTK, labels=myLB, cex.axis=1.2)

          ### 
          matplot(xd, t(fitGSD), log="x", type="l", lty=1, xlab="Grain size (um)", 
                  ylab="Predicted volume percentage (%)", col="skyblue", lwd=1.25, 
                  mgp=c(2.3,1,0), cex.axis=1.25, cex.lab=1.25, xaxt="n")
          axis(side=1, at=myTK, labels=myLB, cex.axis=1.2)

          ### 
          plot(1:m, Angle, type="p", lty=1, xlab="Sample index", 
               ylab="Optimized angle (Degree)", col="brown", lwd=3, 
               mgp=c(2.3,1,0), cex.axis=1.25, cex.lab=1.25)
          abline(h=meanAngle, col="red", lty=2, lwd=2)

          ### 
          plot(1:m, R2, type="p", lty=1, xlab="Sample index", ylab="Optimized R2", 
               col="purple", lwd=3, mgp=c(2.3,1,0), cex.axis=1.25, cex.lab=1.25)
          abline(h=meanR2, col="red", lty=2, lwd=2)

          ###
          ### The fourth plot.
          ###-------------------------------------
          layout(matrix(seq(nr*nc),nrow=nr, ncol=nc, byrow=TRUE), respect=TRUE)
          par(mar=c(0.3,0.3,0.3,0.3))

          ### 
          for (i in 1:m) {
 
            ###
            matplot(xd,cbind(X[i,],fitGSD[i,]), type="l", lty=1, 
                    lwd=2, log="x", xaxt="n", yaxt="n", bty="n",  
                    col=c("red","skyblue"))

            ###
            legend("topleft", legend=c(paste("NO=",i,sep=""),
                   paste("Angle=",round(Angle[i],2),sep=""),
                   paste("R2=",round(R2[i],2),sep="")),
                   bty="n",cex=0.5)

            ###
            box(lwd=3)

        } # end for.
               
          ###  
          dev.off()
          
      } # end if.
      
      ### 
      output <- list("fitGSD"=fitGSD, "abundance"=abundance, "endmember"=endmember,
                     "Angle"=Angle, "meanAngle"=meanAngle, "sdmeanAngle"=sdmeanAngle, 
                     "R2"=R2, "meanR2"=meanR2, "sdmeanR2"=sdmeanR2, "pars"=pars, "xm"=xm)
        
      ###
      invisible(output)

  } # end function PEMMp.
  ###
